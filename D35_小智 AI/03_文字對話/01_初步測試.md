# ä¿®æ”¹

<br>

## é€²å…¥å°ˆæ¡ˆ

1. åˆ‡æ›è·¯å¾‘ã€‚

```bash
cd ~/esp
```

2. é€²å…¥å°ˆæ¡ˆï¼Œå‡å¦‚æ²’å¦åšè¨­å®šï¼Œç›®éŒ„åç¨±æ˜¯ `xiaozhi-esp32`

```bash
cd ~/esp/xiaozhi-esp32
```

## `application.h`

1. åŠ å…¥ `#include <iostream>`ï¼Œ é€™æ¨£ `std::cout` å’Œ `std::cin` æ‰èƒ½åœ¨ `application.cc` ä½¿ç”¨ï¼›å¦å¤–ä¹Ÿè¦åŠ å…¥ `#include <thread>`ï¼Œå› ç‚º `StartListening` æœƒä½¿ç”¨ `std::thread`ã€‚

```cpp
// æ¨™æº–è¼¸å‡ºå…¥
#include <iostream>
// åŸ·è¡Œç·’
#include <thread>
// åŠ å…¥äº’æ–¥é–
#include <mutex>
```

<br>

2. å®£å‘Š `OnIncomingJson` ç‚ºæˆå“¡å‡½å¼ï¼Œé€™æ¨£ `application.cc` æ‰èƒ½èª¿ç”¨ `OnIncomingJson()`ã€‚

    ```cpp
    class Application {
    public:
        /*å…¶é¤˜ä¸è®Š*/
        // æ·»åŠ æ–°çš„æˆå“¡å‡½å¼
        void OnIncomingJson(const cJSON* root);
    };
    ```

<br>

3. æ·»åŠ  InputAudio å‡½æ•¸å¸¶æœ‰åƒæ•¸çš„å®£å‘Šã€‚

    ```cpp
    // ä¿ç•™
    void InputAudio();
    // æ·»åŠ å¸¶æœ‰åƒæ•¸çš„å®£å‘Š
    void InputAudio(const std::string& user_input);
    ```

## `application.cc`

1. åŠ å…¥ `OnIncomingJson` çš„å¯¦ä½œï¼Œè‹¥ç„¡å¯¦ä½œæœƒæç¤ºéŒ¯èª¤ `undefined reference to 'OnIncomingJson'`ã€‚

    ```cpp
    void Application::OnIncomingJson(const cJSON* root) {
        // å¯ä»¥æ ¹æ“šéœ€æ±‚ä¿®æ”¹æ­¤å‡½æ•¸
        ESP_LOGI(TAG, "===æ¥æ”¶åˆ°è³‡æ–™===");
    }
    ```

<br>

3. è¨»è§£åŸæœ¬çš„ `void Application::StartListening()` æ”¹ç‚ºã€‚

```cpp
void Application::StartListening() {
    static std::mutex listen_mutex;
    // ç¢ºä¿åªæœ‰ä¸€å€‹åŸ·è¡Œç·’é€²å…¥
    std::lock_guard<std::mutex> lock(listen_mutex);

    if (device_state_ == kDeviceStateActivating) {
        SetDeviceState(kDeviceStateIdle);
        return;
    }

    if (!protocol_) {
        ESP_LOGE(TAG, "Protocol not initialized");
        return;
    }

    if (keep_listening_) {
        ESP_LOGW(TAG, "Listening thread already running.");
        return;
    }
    // è¨­ç½®ç›£è½ç‹€æ…‹
    keep_listening_ = true;

    // ä½¿ç”¨èƒŒæ™¯åŸ·è¡Œç·’ç›£è½è¼¸å…¥
    std::thread input_thread([this]() {
        while (keep_listening_) {
            std::string user_input;
            std::cout << "\nğŸ“ è¼¸å…¥ä½ çš„è¨Šæ¯: ";
            std::getline(std::cin, user_input);

            if (!user_input.empty()) {
                InputAudio(user_input);
            }
        }
    });
    // è®“åŸ·è¡Œç·’ç¨ç«‹é‹è¡Œ
    input_thread.detach();
}
```

4. å°‡åŸæœ¬çš„å‡½æ•¸å…ˆè¨»è§£èµ·ä¾† `InputAudio`ï¼Œä¿®æ”¹è®“å®ƒç›£è½çµ‚ç«¯æ©Ÿè¼¸å…¥ï¼Œç¢ºä¿å¯ä»¥é€éçµ‚ç«¯æ©Ÿè¼¸å…¥ï¼Œè€Œééº¥å…‹é¢¨æ”¶éŸ³ï¼›é€™è£¡æœƒæ·»åŠ å…©å€‹ç‰ˆæœ¬ã€‚

    ```cpp
    void Application::InputAudio() {
        std::string user_input;
        std::cout << std::endl << "ğŸ“ è¼¸å…¥ä½ çš„è¨Šæ¯: ";
        std::getline(std::cin, user_input);

        if (!user_input.empty()) {
            // èª¿ç”¨å¸¶åƒæ•¸ç‰ˆæœ¬
            InputAudio(user_input);
        }
    }

    void Application::InputAudio(const std::string& user_input) {
        if (user_input == "exit") {
            std::cout << "ğŸ‘‹ å†è¦‹ï¼" << std::endl;
            keep_listening_ = false;
            exit(0);
        }

        cJSON *root = cJSON_CreateObject();
        if (!root) {
            ESP_LOGE(TAG, "JSON å»ºç«‹å¤±æ•—");
            return;
        }

        cJSON_AddStringToObject(root, "type", "stt");
        cJSON_AddStringToObject(root, "text", user_input.c_str());

        ESP_LOGI(TAG, ">> (ä½¿ç”¨è€…): %s", user_input.c_str());
        
        // å‚³é JSON çµ¦æ©Ÿå™¨äººè™•ç†
        OnIncomingJson(root);

        // æ¸…é™¤ JSON ç‰©ä»¶ï¼Œé¿å…è¨˜æ†¶é«”æ´©æ¼
        cJSON_Delete(root);
    }
    ```

<br>

3. ç¢ºä¿ `OnIncomingJson` åœ¨ `InputAudio` å…§è¢«æ­£ç¢ºèª¿ç”¨ï¼Œ`OnIncomingJson(root);` æœƒè™•ç† `stt` è¨Šæ¯ï¼Œæ¨¡æ“¬èªéŸ³è¼¸å…¥ã€‚

<br>

## `main.cc`

1. ä¿®æ”¹å•Ÿå‹•æ‡‰ç”¨çš„ä»£ç¢¼ï¼Œä¸¦åœ¨æœ€å¾Œæ·»åŠ ç›£è½çµ‚ç«¯æ©Ÿã€‚

```cpp
extern "C" void app_main(void)
{
    // åŸæœ¬ä»£ç¢¼ä¸è®Š

    // å•Ÿå‹•æ‡‰ç”¨ç¨‹å¼
    // ä¿®æ”¹
    // Application::GetInstance().Start();
    Application& app = Application::GetInstance();
    app.Start();

    // åªåŸ·è¡Œä¸€æ¬¡ StartListening()
    app.StartListening();

    // ä¿æŒä¸»åŸ·è¡Œç·’é‹è¡Œ
    while (true) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

## é‡æ–°ç·¨è­¯èˆ‡ç‡’éŒ„

1. æ¸…ç† `.o` æ–‡ä»¶ï¼›ç¢ºä¿ä¸æœƒæœ‰èˆŠçš„ç‰©ä»¶æª”æ¡ˆå½±éŸ¿æ–°çš„ç·¨è­¯ã€‚

    ```bash
    idf.py fullclean
    ```

<br>

2. é€²è¡Œç·¨è­¯èˆ‡ç‡’éŒ„ã€‚

    ```bash
    idf.py build
    ```

<br>

3. ç‡’éŒ„ä¸¦å•Ÿå‹•ç›£ç£ã€‚ 

    ```bash
    idf.py flash monitor
    ```

<br>

4. å¦‚æœæ²’å•é¡Œï¼Œæ‡‰è©²å¯ä»¥é †åˆ©é‹è¡Œï¼Œçµ‚ç«¯æ©Ÿæœƒé¡¯ç¤ºï¼Œé€™æœƒç­‰å¾…ä½¿ç”¨è€…è¼¸å…¥ï¼Œä¸¦è§¸ç™¼ `OnIncomingJson` é€²è¡Œå°è©±è™•ç†ï¼Œé€™æ¨£å°±æŠŠèªéŸ³å°è©±åŠŸèƒ½æ”¹ç‚ºçµ‚ç«¯æ©Ÿæ–‡å­—è¼¸å…¥ã€‚

    ```bash
    ğŸ“ è¼¸å…¥ä½ çš„è¨Šæ¯:
    ```

<br>

___

_END_
