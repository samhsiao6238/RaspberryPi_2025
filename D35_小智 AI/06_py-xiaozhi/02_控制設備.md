# 控制設備

_在兩個地方可以看到 `Lamp`_

<br>

## application.py

_編輯這份文件如下_

<br>

1. 編輯 `_initialize_iot_devices` 函數，加入以下標註了 `「+」` 的代碼。

    ```python
    # 這是原本的
    from src.iot.thing_manager import ThingManager
    from src.iot.things.lamp import Lamp
    # 「+」導入新模組
    from src.iot.things.NewThing import NewThing

    # 這是原本的
    thing_manager = ThingManager.get_instance()
    thing_manager.add_thing(Lamp())

    # 「+」添加新設備
    thing_manager.add_thing(NewThing())
    ```

<br>

## 建立新模組 `NewThing.py`

1. 可直接複製 `iot/things` 資料夾中的 `lamp.py`，並更名為 `NewThing.py`。

<br>

2. 編輯內容 `NewThing.py`，使用替換方式，將 `Lamp` 都改為 `NewThing`；這個步驟只是作為示範，可藉此觀察修改部分。

    ![](images/img_13.png)

<br>

3. 將 `NewThing.py` 內容修改如下；以下標註 `「+」` 部分就是新增代碼、`「*」` 就是修改部分。

    ```python
    from src.iot.thing import Thing
    # 「＋」依據新功能加入新模組
    import requests

    class NewThing(Thing):
        def __init__(self):
            # 「*」改為新模組以及新敘述字串
            super().__init__(
                "NewThing",
                "一個測試用的 Line 通知裝置"
            )

            # 「＋」加入新的輸出訊息，供調適目的使用
            print(f"[虛擬設備] Line 通知設備初始化完成")

            # 「＋」註冊屬性 `add_property` 及註冊方法 `add_method`
            # ...
    ```

<br>

## 註冊屬性及方法

_在 `py-xiaozhi` 中，所有的 `物聯網設備` 都是從 `src.iot.thing.Thing` 繼承而來，而 `Thing` 類裡提供了兩個最核心的擴展接口；先說明屬性與方法的註冊，後續再提供所註冊的函數_

<br>

1. 註冊函數；第一個參數是給這個函數在 `ThingManager` 中註冊唯一識別名稱，第二個參數是提示詞，第三個參數則是調用自訂函數。

    ```python
    # 加入函數：將自訂函數加入，並定義 `提示詞`
    self.add_method(
        "GetUSDQuote", "取得美金報價", [], 
        lambda params: self._get_usd_quote()
    )
    ```

<br>

2. 【函數解說】`add_property(name: str, description: str, getter: Callable[[], Awaitable])`。

    ```python
    def add_property(
        self,
        name: str,
        description: str,
        getter: Callable[[], Awaitable]):
        """
        註冊一個「屬性」，前端/伺服器可以讀取這個屬性。
        — name:      屬性的機器識別名（比如 "power"）
        — description: 給 LLM 或 UI 顯示的自然語言描述（比如 "燈是否開啟"）
        — getter:    一個 async 函數，無參數，回傳當前值
        """
    ```

<br>

3. 延續上一點，在設備狀態查詢階段，系統會遍歷所有設備的 `properties`，調用這個 `getter` 拿到最新值，然後打包成 JSON 發給伺服器或 UI；注意 `getter` 必須是一個 `async def`，否則會觸發錯誤 `TypeError: Property getter for '…' must be an async function.`。

    ```python
    async def get_power(self):
        return self.power
    ```

<br>

4. 【函數解說】`add_method(name: str, description: str, parameters: List[Parameter], callback: Callable[[dict], Awaitable])`。

    ```python
    def add_method(
        self,
        name: str,
        description: str,
        parameters: List[Parameter],
        callback: Callable[[dict], Awaitable]):
        """
        註冊一個「行為/命令」，當 LLM 或外部呼叫這個方法時，就執行你給的 callback。
        — name:       內部識別用的方法名（比如 "TurnOn"）
        — description: 給 LLM 匹配用的自然語言短語（比如 "打開燈"）
        — parameters: 方法接受的參數列表（目前多用空列表 []）
        — callback:   一個 async 函數，接受一個 dict 參數，回傳執行結果
        """
    ```

<br>

5. 延續上一點， 當伺服器端或 LLM 分析到用戶說了跟 `description` 匹配的指令，就會透過 `ThingManager.invoke()` 去呼叫這個 `callback`；注意，`callback` 也是必須是 `async def`。

    ```python
    async def _turn_on(self, params):
        self.power = True
        return {"status":"success", "message":"燈已開啟"}
    ```

<br>

6. `add_property` 就是指定類（`Lamp`, `NewThing`）去取得設備的某個狀態交給框架去讀；`add_method` 則是告訴框架如果收到這段指令就執行這裡的動作。只要把這兩個介面正確地傳入一個 `async` 函數，就能被 `MCP/ThingManager` 正常識別、調度。

<br>

## 自定義函數

1. 【自定義函數】取得美元報價。

    ```python
    # 自訂函數：取得報價
    async def _get_usd_quote(self):
        try:
            response = requests.get("https://tw.rter.info/capi.php")
            if response.status_code == 200:
                data = response.json()
                usd_twd = data["USD"]["Exrate"]
                msg = f"目前美金匯率約為 {usd_twd:.2f} 新台幣"
            else:
                msg = "無法取得美金報價（API錯誤）"
        except Exception as e:
            msg = f"取得匯率時發生錯誤：{e}"

        self._send_line_notify(msg)
        print(f"[虛擬設備] 已發送美金報價 Line 訊息：{msg}")
        return {"status": "success", "message": msg}
    ```

<br>

2. 【自定義函數】發送 `Line 通知`；已棄用，會再修正。

    ```python
    async def _send_line_notify(self, message: str):
        token = "WemrA5mtsqcBcvTEG59tXmVGVTDj8wifXH51GzjWXx8"
        url = "https://notify-api.line.me/api/notify"
        headers = {
            "Authorization": f"Bearer {token}"
        }
        data = {
            "message": message
        }
        try:
            response = requests.post(url, headers=headers, data=data)
            if response.status_code != 200:
                print(f"[錯誤] 發送 Line Notify 失敗: {response.text}")
        except Exception as e:
            print(f"[例外] 發送 Line Notify 發生錯誤: {e}")
    ```

    ```python
    import asyncio
    import requests

    async def _get_usd_quote(self, params):
        """
        取得美金報價 (USD→TWD)，並透過 LINE Notify 發送
        """
        try:
            # 在後台線程執行 HTTP 請求，避免阻塞
            response = await asyncio.to_thread(
                requests.get,
                "https://api.exchangerate.host/latest?base=USD&symbols=TWD",
                {"timeout": 5}
            )
            response.raise_for_status()
            data = response.json()

            rate = data.get("rates", {}).get("TWD")
            if rate is None:
                msg = "無法取得美金報價（API 回傳資料缺失）"
            else:
                msg = f"目前美金匯率約為 {rate:.2f} 新台幣"
        except Exception as e:
            msg = f"取得匯率時發生錯誤：{e}"

        # 發送 LINE Notify，這個函數也是 async
        await self._send_line_notify(msg)
        print(f"[虛擬設備] 已發送美金報價 Line 訊息：{msg}")
        return {"status": "success", "message": msg}
    ```


___

_未完_