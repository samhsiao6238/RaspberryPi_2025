# 分散式運算演練

_使用多台樹莓派建立 `K3s` 叢集進行 `數值計算`，並實際測量效能提升_

## 環境檢查

1. 確認所有節點皆為 Ready

    ```bash
    sudo kubectl get nodes
    ```

    ![](images/img_137.png)

2. 限制 `Job` 不要在 `master` 節點運行，為每台工作節點加上標籤。

    ```bash
    for node in raspi-2025-gray raspi-2025-black raspi-2025-blue; do
        sudo kubectl label node $node role=worker
    done
    ```

    ![](images/img_138.png)

3. 建立命名空間 `pi-workload`，所有後續資源都部署在這個命名空間，方便管理與刪除。

```bash
sudo kubectl create namespace pi-workload
```

## 撰寫 Job 定義

1. 建立腳本。

```bash
cd ~/Documents
nano pi-calculation-job.yaml
```

2. 這個 Job 會透過 Python 計算 π 值，並透過 K3s 自動分配到三台 Raspberry Pi 運行。

    ```yaml
    apiVersion: batch/v1
    kind: Job
    metadata:
      name: pi-calculation-job
      namespace: pi-workload
    spec:
      # 產生 3 個獨立 Pod，並同時執行
      completions: 3
      parallelism: 3
      template:
        spec:
          # 只排程到標籤為 role=worker 的節點上
          nodeSelector:
            role: worker
          # 禁止重新啟動，失敗即視為該任務結束
          restartPolicy: Never
          containers:
          - name: pi-calculator
            image: python:3.9-slim
            command: ["python3", "-c"]
            args:
              - |
                import time, random
                def monte_carlo_pi(n):
                    inside = 0
                    for _ in range(n):
                        x, y = random.random(), random.random()
                        if x*x + y*y <= 1:
                            inside += 1
                    return (inside / n) * 4
                n = 10_000_000
                t0 = time.time()
                pi_est = monte_carlo_pi(n)
                dt = time.time() - t0
                print(f"Node {__import__('socket').gethostname()}: π ≈ {pi_est:.6f}, Time: {dt:.2f}s")
    ```

## 部署與監控

1. 刪除舊的 Job。

```bash
sudo kubectl delete job pi-calculation-job \
    --namespace pi-workload --ignore-not-found
```

1. 套用新的 Job

```bash
sudo kubectl apply -f ~/Documents/pi-calculation-job.yaml
```

3. 觀察 Job 狀態，終端機會卡住，等到 completions 欄顯示 3/3，代表所有 Pod 都執行完畢。

```bash
sudo kubectl get jobs -n pi-workload -w
```

4. 查看 Pod 詳細。

```bash
sudo kubectl get pods -n pi-workload -o wide
```

5. 收集並比較計算時間，看到三行訊息，分別顯示各節點的計算時間；平均時間 ≈ 三者平均，用來代表 `分散式執行單次任務` 的耗時，若想比較 `合併效能`，可用 `3 * 平均時間` 與單機測試時間相較。

```bash
sudo kubectl logs -l job-name=pi-calculation-job -n pi-workload
```

## 單機測試

_在本機或任一工作節點執行，確保該節點已安裝 Docker，並能拉取 `python:3.9-slim` 鏡像_

1. 先做小樣本測試快，快速驗證流程

    ```bash
    time docker run --rm python:3.9-slim python3 - << 'EOF'
    print("Start small test")
    import time, random
    def monte_carlo_pi(n):
        inside = 0
        for _ in range(n):
            x, y = random.random(), random.random()
            if x*x + y*y <= 1:
                inside += 1
        return inside / n * 4

    n = 100_000       # 小樣本 10 萬次
    t0 = time.time()
    pi_est = monte_carlo_pi(n)
    dt = time.time() - t0
    print(f"π≈{pi_est:.6f}, Time: {dt:.2f}s")
    EOF
    ```

   * 輸出：

     * `π≈...`：估算值
     * `Time: xx.xx s`：純計算耗時
   * `time` 會同時顯示 `real`（真實時間）、`user`、`sys`。

3. 正式大樣本測試

   ```bash
   time docker run --rm python:3.9-slim python3 - << 'EOF'
   import time, random
   def monte_carlo_pi(n):
       inside = 0
       for _ in range(n):
           x, y = random.random(), random.random()
           if x*x + y*y <= 1:
               inside += 1
       return inside / n * 4

   n = 10_000_000    # 正式樣本 1000 萬次
   t0 = time.time()
   pi_est = monte_carlo_pi(n)
   dt = time.time() - t0
   print(f"π≈{pi_est:.6f}, Time: {dt:.2f}s")
   EOF
   ```

   * 記錄 `Time: xx.xx s` 作為單機完整耗時，記為 Tₛ。



## 結果分析

1. 單機效率

   * Tₛ：上一步大樣本測試得出的耗時。

2. 分散式平均效率

   * 從 Job 日誌取出三個節點各自的耗時（如 `Time: 25.37s`、`26.45s`、`24.89s`），計算平均：

     $$
       T_p = \frac{T_1 + T_2 + T_3}{3}
     $$
   * Tₚ：即為分散式「單份任務」的平均耗時。

3. 加速比（Speed-up）

   $$
     \text{Speed-up} = \frac{Tₛ}{Tₚ}
   $$

   * 若 Speed-up > 1，表示分散式較單機更快。

4. 平行效率（Parallel Efficiency）

   $$
     \text{Efficiency} = \frac{\text{Speed-up}}{\text{節點數}}
       = \frac{Tₛ}{N \times Tₚ}
   $$

   * 節點數 N=3，此值反映資源利用率。

5. 報告結果

   * 將 Tₛ、(T₁,T₂,T₃)、Tₚ、Speed-up、Efficiency 填入表格或 CSV。
   * 如有需要，用 Python / Excel 繪製柱狀圖或折線圖呈現。



## 清理資源

1. 刪除整個命名空間（連同所有 Job、Pod 一次移除）：

   ```bash
   sudo kubectl delete namespace pi-workload
   ```
2. 如要保留命名空間，只刪 Job：

   ```bash
   sudo kubectl delete job pi-calculation-job -n pi-workload
   ```
